/**
 * K6 Load Test: Appointment Booking Peak Scenario
 *
 * Simulates 50 concurrent users booking appointments simultaneously
 * Tests appointment scheduling system under peak load
 */

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend } from 'k6/metrics';

// Custom metrics
const errorRate = new Rate('errors');
const bookingDuration = new Trend('booking_duration');

// Test configuration
export const options = {
  stages: [
    { duration: '1m', target: 10 },   // Warm up
    { duration: '2m', target: 50 },   // Peak load
    { duration: '5m', target: 50 },   // Sustained load
    { duration: '1m', target: 0 },    // Cool down
  ],
  thresholds: {
    'http_req_duration': ['p(95)<3000', 'p(99)<6000'],
    'http_req_failed': ['rate<0.001'],
    'booking_duration': ['p(95)<5000'], // Full booking flow under 5s for 95%
    'errors': ['rate<0.01'],
  },
};

const BASE_URL = __ENV.BASE_URL || 'https://holilabs.xyz';
const API_KEY = __ENV.API_KEY || '';

// Provider IDs for testing
const PROVIDERS = [
  'dr-smith-md',
  'dr-johnson-do',
  'nurse-practitioner-williams',
  'dr-brown-md',
];

// Appointment types
const APPOINTMENT_TYPES = [
  'consultation',
  'follow-up',
  'annual-physical',
  'urgent-care',
];

export default function () {
  const startTime = Date.now();

  // 1. View available slots
  const provider = PROVIDERS[Math.floor(Math.random() * PROVIDERS.length)];
  const appointmentType = APPOINTMENT_TYPES[Math.floor(Math.random() * APPOINTMENT_TYPES.length)];

  // Get tomorrow's date
  const tomorrow = new Date();
  tomorrow.setDate(tomorrow.getDate() + 1);
  const dateStr = tomorrow.toISOString().split('T')[0];

  const availabilityResponse = http.get(
    `${BASE_URL}/api/appointments/availability?providerId=${provider}&date=${dateStr}&type=${appointmentType}`,
    {
      headers: {
        'Authorization': `Bearer ${API_KEY}`,
      },
      tags: { name: 'CheckAvailability' },
    }
  );

  const availabilitySuccess = check(availabilityResponse, {
    'availability loaded': (r) => r.status === 200,
    'has available slots': (r) => {
      try {
        const data = JSON.parse(r.body);
        return Array.isArray(data.slots) && data.slots.length > 0;
      } catch {
        return false;
      }
    },
  });

  if (!availabilitySuccess) {
    errorRate.add(1);
    return; // Exit if no slots available
  }

  sleep(2); // User reviews available times

  // 2. Book an appointment
  const slots = JSON.parse(availabilityResponse.body).slots;
  const selectedSlot = slots[Math.floor(Math.random() * Math.min(slots.length, 3))]; // Pick from first 3 slots

  const bookingPayload = JSON.stringify({
    providerId: provider,
    patientId: `patient-${__VU}-${__ITER}`, // Unique per virtual user and iteration
    appointmentType: appointmentType,
    startTime: selectedSlot.startTime,
    endTime: selectedSlot.endTime,
    reason: 'Load test appointment - please ignore',
    notes: `Generated by k6 load test - VU:${__VU} Iter:${__ITER}`,
  });

  const bookingResponse = http.post(
    `${BASE_URL}/api/appointments/book`,
    bookingPayload,
    {
      headers: {
        'Authorization': `Bearer ${API_KEY}`,
        'Content-Type': 'application/json',
      },
      tags: { name: 'BookAppointment' },
    }
  );

  const bookingSuccess = check(bookingResponse, {
    'appointment booked': (r) => r.status === 200 || r.status === 201,
    'booking has confirmation ID': (r) => {
      try {
        const data = JSON.parse(r.body);
        return data.id !== undefined || data.appointmentId !== undefined;
      } catch {
        return false;
      }
    },
    'booking response time acceptable': (r) => r.timings.duration < 3000,
  });

  if (!bookingSuccess) {
    errorRate.add(1);
  }

  // Record full booking flow duration
  const endTime = Date.now();
  bookingDuration.add(endTime - startTime);

  sleep(1); // User reviews confirmation

  // 3. Verify booking appears in patient's appointments
  if (bookingSuccess) {
    const verifyResponse = http.get(
      `${BASE_URL}/api/appointments/list?patientId=patient-${__VU}-${__ITER}`,
      {
        headers: {
          'Authorization': `Bearer ${API_KEY}`,
        },
        tags: { name: 'VerifyBooking' },
      }
    );

    const verifySuccess = check(verifyResponse, {
      'appointments list loaded': (r) => r.status === 200,
      'booking appears in list': (r) => {
        try {
          const data = JSON.parse(r.body);
          return Array.isArray(data.appointments) && data.appointments.length > 0;
        } catch {
          return false;
        }
      },
    });

    if (!verifySuccess) {
      errorRate.add(1);
    }
  }

  sleep(2); // Think time
}

export function handleSummary(data) {
  let summary = '\n';
  summary += '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n';
  summary += '  APPOINTMENT BOOKING PEAK TEST RESULTS\n';
  summary += '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n';

  if (data.metrics.http_req_duration) {
    const p95 = data.metrics.http_req_duration.values['p(95)'];
    const p99 = data.metrics.http_req_duration.values['p(99)'];
    summary += `  Response Time (p95): ${p95.toFixed(2)}ms ${p95 < 3000 ? '✓' : '✗'}\n`;
    summary += `  Response Time (p99): ${p99.toFixed(2)}ms ${p99 < 6000 ? '✓' : '✗'}\n`;
  }

  if (data.metrics.booking_duration) {
    const p95 = data.metrics.booking_duration.values['p(95)'];
    summary += `  Full Booking Flow (p95): ${p95.toFixed(2)}ms ${p95 < 5000 ? '✓' : '✗'}\n`;
  }

  if (data.metrics.http_req_failed) {
    const rate = data.metrics.http_req_failed.values.rate;
    summary += `  Error Rate: ${(rate * 100).toFixed(3)}% ${rate < 0.001 ? '✓' : '✗'}\n`;
  }

  if (data.metrics.http_reqs) {
    summary += `  Total Requests: ${data.metrics.http_reqs.values.count}\n`;
  }

  summary += '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n';

  return {
    'summary-appointment-booking.json': JSON.stringify(data),
    'stdout': summary,
  };
}
