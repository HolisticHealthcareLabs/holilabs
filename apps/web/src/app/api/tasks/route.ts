/**
 * Provider Task Management API
 *
 * GET /api/tasks - List tasks with filters
 * POST /api/tasks - Create new task
 */

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import logger from '@/lib/logger';
import { emitTaskCreatedEvent } from '@/lib/socket-server';

export const dynamic = 'force-dynamic';

/**
 * GET /api/tasks
 * List tasks with smart filtering for optimal UX
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);

    // Get current user (in a real app, from session/auth)
    const userId = searchParams.get('userId') || 'system';

    // Filters for excellent UX
    const view = searchParams.get('view') || 'today'; // today, week, all, overdue
    const priority = searchParams.get('priority'); // URGENT, HIGH, NORMAL, LOW
    const category = searchParams.get('category');
    const status = searchParams.get('status') || 'PENDING'; // PENDING, IN_PROGRESS, COMPLETED, DISMISSED

    // Build smart date filters based on view
    const now = new Date();
    let dateFilter = {};

    if (view === 'today') {
      const endOfDay = new Date(now);
      endOfDay.setHours(23, 59, 59, 999);
      dateFilter = {
        OR: [
          { dueDate: { lte: endOfDay } },
          { dueDate: null }, // Include undated tasks in "today" view
        ],
      };
    } else if (view === 'week') {
      const endOfWeek = new Date(now);
      endOfWeek.setDate(now.getDate() + 7);
      dateFilter = {
        dueDate: { lte: endOfWeek },
      };
    } else if (view === 'overdue') {
      dateFilter = {
        dueDate: { lt: now },
        status: { in: ['PENDING', 'IN_PROGRESS'] },
      };
    }

    // Build where clause
    const where: any = {
      assignedTo: userId,
      ...(status !== 'all' && { status }),
      ...(priority && { priority }),
      ...(category && { category }),
      ...dateFilter,
    };

    // Get tasks with related data
    const tasks = await prisma.providerTask.findMany({
      where,
      orderBy: [
        { priority: 'desc' }, // URGENT first
        { dueDate: 'asc' },  // Earliest due date first
        { createdAt: 'desc' }, // Newest first if no due date
      ],
      take: 100, // Limit for performance
    });

    // Get counts for each view (for UX badges)
    const [todayCount, overdueCount, allPendingCount] = await Promise.all([
      prisma.providerTask.count({
        where: {
          assignedTo: userId,
          status: { in: ['PENDING', 'IN_PROGRESS'] },
          OR: [
            { dueDate: { lte: new Date(now.setHours(23, 59, 59, 999)) } },
            { dueDate: null },
          ],
        },
      }),
      prisma.providerTask.count({
        where: {
          assignedTo: userId,
          status: { in: ['PENDING', 'IN_PROGRESS'] },
          dueDate: { lt: now },
        },
      }),
      prisma.providerTask.count({
        where: {
          assignedTo: userId,
          status: { in: ['PENDING', 'IN_PROGRESS'] },
        },
      }),
    ]);

    logger.info({
      event: 'tasks_retrieved',
      count: tasks.length,
      view,
      userId,
    });

    return NextResponse.json({
      success: true,
      data: tasks,
      counts: {
        today: todayCount,
        overdue: overdueCount,
        all: allPendingCount,
      },
    });
  } catch (error) {
    logger.error({
      event: 'tasks_get_error',
      error: error instanceof Error ? error.message : 'Unknown error',
    });

    return NextResponse.json(
      {
        success: false,
        error: 'Failed to fetch tasks',
      },
      { status: 500 }
    );
  }
}

/**
 * POST /api/tasks
 * Create a new task
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { title, description, category, priority, dueDate, assignedTo, relatedType, relatedId } = body;

    // Validation
    if (!title || !category || !assignedTo) {
      return NextResponse.json(
        {
          success: false,
          error: 'Missing required fields: title, category, assignedTo',
        },
        { status: 400 }
      );
    }

    // Create task
    const task = await prisma.providerTask.create({
      data: {
        title,
        description,
        category,
        priority: priority || 'NORMAL',
        assignedTo,
        dueDate: dueDate ? new Date(dueDate) : null,
        relatedType,
        relatedId,
        autoGenerated: false,
      },
    });

    logger.info({
      event: 'task_created',
      taskId: task.id,
      category: task.category,
      priority: task.priority,
    });

    // Real-time Socket.IO broadcast for task creation
    // Pushes to assignee's room for immediate UI update
    emitTaskCreatedEvent({
      id: task.id,
      title: task.title,
      category: task.category,
      priority: task.priority as 'URGENT' | 'HIGH' | 'NORMAL' | 'LOW',
      status: task.status as 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'DISMISSED',
      assignedTo: task.assignedTo,
      dueDate: task.dueDate ?? undefined,
      relatedType: task.relatedType ?? undefined,
      relatedId: task.relatedId ?? undefined,
      userId: assignedTo, // Creator is also the context user
    });

    return NextResponse.json({
      success: true,
      data: task,
    });
  } catch (error) {
    logger.error({
      event: 'task_create_error',
      error: error instanceof Error ? error.message : 'Unknown error',
    });

    return NextResponse.json(
      {
        success: false,
        error: 'Failed to create task',
      },
      { status: 500 }
    );
  }
}
