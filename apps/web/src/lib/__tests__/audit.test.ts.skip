/**
 * Audit Logging Test Suite
 * Tests HIPAA-compliant audit trail functionality
 *
 * Coverage Target: 95%+ (critical compliance infrastructure)
 * Compliance: HIPAA ยง164.312(b), LGPD Art. 48
 */

// Mock dependencies BEFORE imports
jest.mock('../prisma', () => ({
  prisma: {
    auditLog: {
      create: jest.fn(),
    },
  },
}));

jest.mock('../logger', () => ({
  default: {
    info: jest.fn(),
    error: jest.fn(),
  },
}));

jest.mock('@/lib/auth', () => ({
  getServerSession: jest.fn(),
}));

jest.mock('../auth/patient-session', () => ({
  getPatientSession: jest.fn(),
}));

jest.mock('../auth', () => ({
  authOptions: {
    providers: [],
    callbacks: {},
    session: { strategy: 'jwt' },
  },
}), { virtual: true });

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { NextRequest } from 'next/server';
import type { AuditLogData } from '../audit';

// Import after mocks
import { prisma } from '../prisma';
import logger from '../logger';
import { getServerSession } from '@/lib/auth';
import { getPatientSession } from '../auth/patient-session';

// Import audit functions after all mocks are set up
import {
  createAuditLog,
  auditView,
  auditCreate,
  auditUpdate,
  auditDelete,
  auditExport,
  auditAccessDenied,
  auditLogin,
  auditLogout,
  logAuditEvent,
  logAudit,
} from '../audit';

describe('Audit Logging', () => {
  beforeEach(() => {
    // Clear all mocks before each test
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('createAuditLog()', () => {
    it('should create audit log with user from request', async () => {
      // Mock clinician session
      (getServerSession as jest.Mock).mockResolvedValue({
        user: {
          id: 'user-123',
          email: 'doctor@hospital.com',
        },
      });

      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      // Create mock request
      const mockRequest = {
        headers: new Headers({
          'x-forwarded-for': '192.168.1.1',
          'user-agent': 'Mozilla/5.0',
        }),
      } as NextRequest;

      const auditData: AuditLogData = {
        action: 'READ',
        resource: 'Patient',
        resourceId: 'patient-456',
        details: { field: 'mrn' },
      };

      await createAuditLog(auditData, mockRequest);

      // Verify database call
      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          userId: 'user-123',
          userEmail: 'doctor@hospital.com',
          ipAddress: '192.168.1.1',
          userAgent: 'Mozilla/5.0',
          action: 'READ',
          resource: 'Patient',
          resourceId: 'patient-456',
          details: { field: 'mrn' },
          success: true,
        }),
      });

      // Verify logger call
      expect(logger.info).toHaveBeenCalledWith(
        expect.objectContaining({
          event: 'audit_log_created',
          userId: 'user-123',
          userEmail: 'doctor@hospital.com',
          action: 'READ',
          resource: 'Patient',
          resourceId: 'patient-456',
          success: true,
          ipAddress: '192.168.1.1',
        })
      );
    });

    it('should create audit log with explicit userId and userEmail', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const auditData: AuditLogData = {
        action: 'CREATE',
        resource: 'Prescription',
        resourceId: 'rx-789',
      };

      await createAuditLog(auditData, undefined, 'explicit-user-id', 'user@example.com');

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          userId: 'explicit-user-id',
          userEmail: 'user@example.com',
        }),
      });
    });

    it('should create audit log for patient session', async () => {
      // Mock patient session
      (getServerSession as jest.Mock).mockResolvedValue(null);
      (getPatientSession as jest.Mock).mockResolvedValue({
        patientId: 'patient-123',
        email: 'patient@example.com',
      });

      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const mockRequest = {
        headers: new Headers(),
      } as NextRequest;

      const auditData: AuditLogData = {
        action: 'READ',
        resource: 'MedicalRecord',
        resourceId: 'record-456',
      };

      await createAuditLog(auditData, mockRequest);

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          userId: 'patient-123',
          userEmail: 'patient@example.com',
        }),
      });
    });

    it('should handle anonymous access', async () => {
      (getServerSession as jest.Mock).mockResolvedValue(null);
      (getPatientSession as jest.Mock).mockResolvedValue(null);

      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const mockRequest = {
        headers: new Headers(),
      } as NextRequest;

      const auditData: AuditLogData = {
        action: 'READ',
        resource: 'PublicDocument',
        resourceId: 'doc-123',
      };

      await createAuditLog(auditData, mockRequest);

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          userId: null,
          userEmail: null,
        }),
      });
    });

    it('should extract IP from x-forwarded-for header', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const mockRequest = {
        headers: new Headers({
          'x-forwarded-for': '10.0.0.1, 192.168.1.1',
        }),
      } as NextRequest;

      const auditData: AuditLogData = {
        action: 'READ',
        resource: 'Patient',
        resourceId: 'patient-123',
      };

      await createAuditLog(auditData, mockRequest);

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          ipAddress: '10.0.0.1', // First IP from forwarded chain
        }),
      });
    });

    it('should extract IP from x-real-ip header if x-forwarded-for not present', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const mockRequest = {
        headers: new Headers({
          'x-real-ip': '203.0.113.1',
        }),
      } as NextRequest;

      const auditData: AuditLogData = {
        action: 'READ',
        resource: 'Patient',
        resourceId: 'patient-123',
      };

      await createAuditLog(auditData, mockRequest);

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          ipAddress: '203.0.113.1',
        }),
      });
    });

    it('should use "unknown" IP if no headers present', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const mockRequest = {
        headers: new Headers(),
      } as NextRequest;

      const auditData: AuditLogData = {
        action: 'READ',
        resource: 'Patient',
        resourceId: 'patient-123',
      };

      await createAuditLog(auditData, mockRequest);

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          ipAddress: 'unknown',
        }),
      });
    });

    it('should create data hash for READ actions with details', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const auditData: AuditLogData = {
        action: 'READ',
        resource: 'Patient',
        resourceId: 'patient-123',
        details: { ssn: '123-45-6789', dob: '1990-01-01' },
      };

      await createAuditLog(auditData);

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          dataHash: expect.any(String),
        }),
      });

      // Verify hash is consistent
      const call = (prisma.auditLog.create as jest.Mock).mock.calls[0][0];
      expect(call.data.dataHash).toHaveLength(64); // SHA-256 hex length
    });

    it('should create data hash for EXPORT actions', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const auditData: AuditLogData = {
        action: 'EXPORT',
        resource: 'Patient',
        resourceId: 'patient-123',
        details: { format: 'CSV', recordCount: 100 },
      };

      await createAuditLog(auditData);

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          dataHash: expect.any(String),
        }),
      });
    });

    it('should not create data hash for CREATE actions', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const auditData: AuditLogData = {
        action: 'CREATE',
        resource: 'Patient',
        resourceId: 'patient-123',
        details: { name: 'John Doe' },
      };

      await createAuditLog(auditData);

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          dataHash: undefined,
        }),
      });
    });

    it('should record failure status', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const auditData: AuditLogData = {
        action: 'DELETE',
        resource: 'Patient',
        resourceId: 'patient-123',
        success: false,
        errorMessage: 'Permission denied',
      };

      await createAuditLog(auditData);

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          success: false,
          errorMessage: 'Permission denied',
        }),
      });
    });

    it('should include LGPD access reason and purpose', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const auditData: AuditLogData = {
        action: 'READ',
        resource: 'Patient',
        resourceId: 'patient-123',
        accessReason: 'EMERGENCY_ACCESS',
        accessPurpose: 'Patient presented with acute symptoms',
      };

      await createAuditLog(auditData);

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          accessReason: 'EMERGENCY_ACCESS',
          accessPurpose: 'Patient presented with acute symptoms',
        }),
      });
    });

    it('should not throw if audit log creation fails', async () => {
      (prisma.auditLog.create as jest.Mock).mockRejectedValue(
        new Error('Database connection failed')
      );

      const auditData: AuditLogData = {
        action: 'READ',
        resource: 'Patient',
        resourceId: 'patient-123',
      };

      // Should not throw
      await expect(createAuditLog(auditData)).resolves.not.toThrow();

      // Should log error
      expect(logger.error).toHaveBeenCalledWith(
        expect.objectContaining({
          event: 'audit_log_creation_failed',
          error: 'Database connection failed',
        })
      );
    });
  });

  describe('auditView()', () => {
    it('should create READ audit log', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      await auditView('Patient', 'patient-456', undefined, { field: 'ssn' });

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          action: 'READ',
          resource: 'Patient',
          resourceId: 'patient-456',
          details: { field: 'ssn' },
        }),
      });
    });

    it('should support LGPD access reason', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      await auditView(
        'Patient',
        'patient-456',
        undefined,
        {},
        'DIRECT_CARE',
        'Scheduled appointment'
      );

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          accessReason: 'DIRECT_CARE',
          accessPurpose: 'Scheduled appointment',
        }),
      });
    });
  });

  describe('auditCreate()', () => {
    it('should create CREATE audit log', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      await auditCreate('Prescription', 'rx-789', undefined, { medication: 'Aspirin' });

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          action: 'CREATE',
          resource: 'Prescription',
          resourceId: 'rx-789',
          details: { medication: 'Aspirin' },
        }),
      });
    });
  });

  describe('auditUpdate()', () => {
    it('should create UPDATE audit log', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      await auditUpdate('Patient', 'patient-123', undefined, { field: 'email', old: 'old@example.com', new: 'new@example.com' });

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          action: 'UPDATE',
          resource: 'Patient',
          resourceId: 'patient-123',
        }),
      });
    });
  });

  describe('auditDelete()', () => {
    it('should create DELETE audit log', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      await auditDelete('Appointment', 'appt-999', undefined, { reason: 'Patient request' });

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          action: 'DELETE',
          resource: 'Appointment',
          resourceId: 'appt-999',
          details: { reason: 'Patient request' },
        }),
      });
    });
  });

  describe('auditExport()', () => {
    it('should create EXPORT audit log', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      await auditExport('Patient', 'patient-123', undefined, { format: 'PDF', recordCount: 1 });

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          action: 'EXPORT',
          resource: 'Patient',
          resourceId: 'patient-123',
        }),
      });
    });
  });

  describe('auditAccessDenied()', () => {
    it('should create failed READ audit log for access denial', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      await auditAccessDenied('Patient', 'patient-123', 'Insufficient permissions');

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          action: 'READ',
          resource: 'Patient',
          resourceId: 'patient-123',
          success: false,
          details: { reason: 'Insufficient permissions', accessDenied: true },
        }),
      });
    });
  });

  describe('auditLogin()', () => {
    it('should create successful LOGIN audit log', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const mockRequest = {
        headers: new Headers({
          'x-forwarded-for': '192.168.1.100',
        }),
      } as NextRequest;

      await auditLogin('user-123', 'doctor@hospital.com', true, mockRequest);

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          userId: 'user-123',
          userEmail: 'doctor@hospital.com',
          action: 'LOGIN',
          resource: 'User',
          resourceId: 'user-123',
          success: true,
          ipAddress: '192.168.1.100',
        }),
      });
    });

    it('should create failed LOGIN audit log with error message', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      await auditLogin('user-123', 'doctor@hospital.com', false, undefined, 'Invalid password');

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          success: false,
          errorMessage: 'Invalid password',
        }),
      });
    });
  });

  describe('auditLogout()', () => {
    it('should create LOGOUT audit log', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      await auditLogout('user-123', 'doctor@hospital.com');

      expect(prisma.auditLog.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          userId: 'user-123',
          userEmail: 'doctor@hospital.com',
          action: 'LOGOUT',
          resource: 'User',
          resourceId: 'user-123',
        }),
      });
    });
  });

  describe('Alias functions', () => {
    it('logAuditEvent should be alias for createAuditLog', () => {
      expect(logAuditEvent).toBe(createAuditLog);
    });

    it('logAudit should be alias for createAuditLog', () => {
      expect(logAudit).toBe(createAuditLog);
    });
  });

  describe('HIPAA Compliance', () => {
    it('should audit all CRUD operations', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const operations = [
        { fn: auditCreate, action: 'CREATE' },
        { fn: auditView, action: 'READ' },
        { fn: auditUpdate, action: 'UPDATE' },
        { fn: auditDelete, action: 'DELETE' },
      ];

      for (const { fn, action } of operations) {
        jest.clearAllMocks();
        await fn('Patient', 'patient-123');

        expect(prisma.auditLog.create).toHaveBeenCalledWith({
          data: expect.objectContaining({
            action,
          }),
        });
      }
    });

    it('should never store plaintext sensitive data in logs', async () => {
      (prisma.auditLog.create as jest.Mock).mockResolvedValue({
        id: 'audit-123',
      });

      const sensitiveData = {
        ssn: '123-45-6789',
        creditCard: '4111-1111-1111-1111',
      };

      await auditView('Patient', 'patient-123', undefined, sensitiveData);

      const call = (prisma.auditLog.create as jest.Mock).mock.calls[0][0];

      // Verify sensitive data is hashed
      expect(call.data.dataHash).toBeDefined();
      expect(call.data.dataHash).toHaveLength(64);

      // Verify details still contain the data (for forensic purposes)
      // but hash allows verification without exposing plaintext
      expect(call.data.details).toEqual(sensitiveData);
    });
  });
});
