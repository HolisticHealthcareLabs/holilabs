// Holi Labs Healthcare Platform - Database Schema
// Blockchain-Ready | HIPAA-Compliant | Web3-Compatible

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USERS & AUTHENTICATION (Non-PHI - Can also use Supabase)
// ============================================================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  supabaseId    String?   @unique // Link to Supabase Auth

  // Blockchain fields
  walletAddress String?   @unique // Future: Web3 login
  publicKey     String?

  // Profile
  firstName     String
  lastName      String
  role          UserRole  @default(CLINICIAN)
  specialty     String?
  licenseNumber String?
  npi           String?   // National Provider Identifier (US only)

  // Security
  mfaEnabled    Boolean   @default(false)
  lastLoginAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  patients      Patient[]
  auditLogs     AuditLog[]
  prescriptions Prescription[]
  appointments  Appointment[]
  calendarIntegrations CalendarIntegration[]
  scribeSessions ScribeSession[]
  soapNotes     SOAPNote[]
  formTemplates FormTemplate[]
  formInstances FormInstance[]

  @@index([email])
  @@index([walletAddress])
  @@map("users")
}

enum UserRole {
  ADMIN
  CLINICIAN
  NURSE
  STAFF
}

// ============================================================================
// PATIENT AUTHENTICATION (Separate from PHI Patient records)
// ============================================================================

model PatientUser {
  id                String    @id @default(cuid())
  patientId         String    @unique
  patient           Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Contact (for authentication)
  email             String    @unique
  phone             String?   @unique

  // Verification status
  emailVerifiedAt   DateTime?
  phoneVerifiedAt   DateTime?

  // Security
  mfaEnabled        Boolean   @default(false)
  lastLoginAt       DateTime?
  lastLoginIp       String?
  loginAttempts     Int       @default(0)
  lockedUntil       DateTime?

  // Metadata
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  magicLinks        MagicLink[]
  otpCodes          OTPCode[]

  @@index([email])
  @@index([phone])
  @@index([patientId])
  @@map("patient_users")
}

model MagicLink {
  id                String      @id @default(cuid())
  patientUserId     String
  patientUser       PatientUser @relation(fields: [patientUserId], references: [id], onDelete: Cascade)

  // Token details
  token             String      @unique @default(cuid())
  tokenHash         String      @unique  // SHA-256 hash of token for lookup

  // Expiration
  expiresAt         DateTime
  usedAt            DateTime?

  // Security
  ipAddress         String?
  userAgent         String?     @db.Text

  // Metadata
  createdAt         DateTime    @default(now())

  @@index([token])
  @@index([tokenHash])
  @@index([patientUserId])
  @@index([expiresAt])
  @@map("magic_links")
}

model OTPCode {
  id                String      @id @default(cuid())
  patientUserId     String
  patientUser       PatientUser @relation(fields: [patientUserId], references: [id], onDelete: Cascade)

  // Code details
  code              String      // 6-digit code
  codeHash          String      @unique  // SHA-256 hash

  // Expiration (10 minutes)
  expiresAt         DateTime
  usedAt            DateTime?

  // Security
  attempts          Int         @default(0)
  maxAttempts       Int         @default(3)

  // Delivery
  sentVia           OTPChannel  @default(SMS)
  recipientPhone    String?
  recipientEmail    String?

  // Metadata
  createdAt         DateTime    @default(now())

  @@index([codeHash])
  @@index([patientUserId])
  @@index([expiresAt])
  @@map("otp_codes")
}

enum OTPChannel {
  SMS
  EMAIL
  WHATSAPP
}

// ============================================================================
// MESSAGING (Clinician ↔ Patient Communication)
// ============================================================================

model Message {
  id                String      @id @default(cuid())

  // Sender/Recipient (polymorphic)
  fromUserId        String
  fromUserType      UserType
  toUserId          String
  toUserType        UserType

  // Always link to patient for context
  patientId         String
  patient           Patient     @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Content
  subject           String?
  body              String      @db.Text

  // Attachments
  attachments       Json?       // Array of { fileName, fileUrl, fileType, fileSize }

  // Threading
  parentMessageId   String?
  parentMessage     Message?    @relation("MessageThread", fields: [parentMessageId], references: [id], onDelete: SetNull)
  replies           Message[]   @relation("MessageThread")

  // Status
  readAt            DateTime?
  archivedAt        DateTime?

  // Note: No direct FK relations due to polymorphic nature
  // Use fromUserId + fromUserType to lookup sender
  // Use toUserId + toUserType to lookup recipient

  // Metadata
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  @@index([fromUserId])
  @@index([toUserId])
  @@index([patientId])
  @@index([readAt])
  @@index([createdAt])
  @@map("messages")
}

enum UserType {
  CLINICIAN
  PATIENT
}

// ============================================================================
// NOTIFICATIONS (Real-time Updates)
// ============================================================================

model Notification {
  id                String      @id @default(cuid())

  // Recipient (polymorphic - clinician or patient)
  recipientId       String
  recipientType     UserType

  // Notification details
  type              NotificationType
  title             String
  message           String      @db.Text

  // Action/Link
  actionUrl         String?     @db.Text  // e.g., "/portal/appointments/123"
  actionLabel       String?     // e.g., "View Appointment"

  // Related resources
  resourceType      String?     // e.g., "Appointment", "Message", "Document"
  resourceId        String?

  // Status
  isRead            Boolean     @default(false)
  readAt            DateTime?

  // Delivery channels
  deliveredInApp    Boolean     @default(false)
  deliveredEmail    Boolean     @default(false)
  deliveredSMS      Boolean     @default(false)

  emailSentAt       DateTime?
  smsSentAt         DateTime?

  // Priority
  priority          NotificationPriority @default(NORMAL)

  // Expiration (auto-delete old notifications)
  expiresAt         DateTime?

  // Metadata
  metadata          Json?       // Additional context

  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  @@index([recipientId, recipientType])
  @@index([isRead])
  @@index([createdAt])
  @@index([expiresAt])
  @@index([type])
  @@map("notifications")
}

enum NotificationType {
  APPOINTMENT_REMINDER
  APPOINTMENT_CONFIRMED
  APPOINTMENT_CANCELLED
  APPOINTMENT_RESCHEDULED
  NEW_MESSAGE
  MESSAGE_REPLY
  NEW_DOCUMENT
  DOCUMENT_SHARED
  NEW_PRESCRIPTION
  PRESCRIPTION_READY
  LAB_RESULT_AVAILABLE
  MEDICATION_REMINDER
  CONSULTATION_COMPLETED
  SOAP_NOTE_READY
  CONSENT_REQUIRED
  PAYMENT_DUE
  PAYMENT_RECEIVED
  SYSTEM_ALERT
  SECURITY_ALERT
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// ============================================================================
// HEALTH METRICS (Patient Self-Reported Data)
// ============================================================================

model HealthMetric {
  id                String      @id @default(cuid())
  patientId         String
  patient           Patient     @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Metric details
  metricType        MetricType
  value             Json        // Flexible structure based on metric type
  unit              String?     // e.g., "kg", "mmHg", "mg/dL"

  // Timing
  recordedAt        DateTime    // When the measurement was taken

  // Source
  source            MetricSource @default(PATIENT_MANUAL)
  deviceName        String?     // e.g., "Apple Watch", "Omron BP Monitor"

  // Context
  notes             String?     @db.Text
  tags              String[]    // e.g., ["fasting", "morning", "post-meal"]

  // Quality
  isOutOfRange      Boolean     @default(false)
  flaggedForReview  Boolean     @default(false)
  reviewedAt        DateTime?
  reviewedBy        String?     // User ID

  // Metadata
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  @@index([patientId])
  @@index([metricType])
  @@index([recordedAt])
  @@index([flaggedForReview])
  @@map("health_metrics")
}

enum MetricType {
  WEIGHT
  HEIGHT
  BLOOD_PRESSURE
  HEART_RATE
  TEMPERATURE
  BLOOD_GLUCOSE
  GLUCOSE  // Alias for BLOOD_GLUCOSE for API compatibility
  OXYGEN_SATURATION
  STEPS
  SLEEP_HOURS
  PAIN_LEVEL
  MOOD
  MEDICATION_ADHERENCE
  CUSTOM
  OTHER  // Alias for CUSTOM for API compatibility
}

enum MetricSource {
  PATIENT_MANUAL
  CLINICIAN_MEASURED
  DEVICE_SYNC
  SMART_SCALE
  FITNESS_TRACKER
  BLOOD_PRESSURE_MONITOR
  GLUCOMETER
  APPLE_HEALTH
  GOOGLE_FIT
}

// ============================================================================
// DOCUMENT SHARING (Patient-Controlled Access)
// ============================================================================

model DocumentShare {
  id                String      @id @default(cuid())
  patientId         String
  patient           Patient     @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // What's being shared
  documentType      ShareableType
  documentId        String      // ID of the SOAP note, prescription, document, etc.
  documentIds       String[]    // Allow sharing multiple items at once

  // Access control
  shareToken        String      @unique @default(cuid())
  shareTokenHash    String      @unique  // SHA-256 for lookup

  // Recipient
  recipientEmail    String?
  recipientPhone    String?
  recipientName     String?
  purpose           String?     @db.Text  // Why are they sharing it?

  // Expiration
  expiresAt         DateTime?
  accessCount       Int         @default(0)
  maxAccesses       Int?        // Optional limit

  // Access tracking
  accessedAt        DateTime?
  lastAccessedAt    DateTime?
  accessIpAddresses String[]    // Track all IPs that accessed

  // Permissions
  allowDownload     Boolean     @default(true)
  requirePassword   Boolean     @default(false)
  passwordHash      String?     // If password protection is enabled

  // Status
  isActive          Boolean     @default(true)
  revokedAt         DateTime?
  revokedBy         String?     // PatientUser ID

  // Metadata
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  @@index([shareToken])
  @@index([shareTokenHash])
  @@index([patientId])
  @@index([expiresAt])
  @@index([isActive])
  @@map("document_shares")
}

enum ShareableType {
  SOAP_NOTE
  PRESCRIPTION
  LAB_RESULT
  IMAGING
  DOCUMENT
  MEDICAL_RECORD_BUNDLE
}

// ============================================================================
// PATIENTS (PHI - Encrypted at rest)
// ============================================================================

model Patient {
  id                String    @id @default(cuid())

  // Blockchain fields - CRITICAL for Web3 pivot
  blockchainId      String?   @unique  // Future: Patient's wallet address
  dataHash          String?              // Hash of critical patient data
  lastHashUpdate    DateTime?

  // Personal Info (ENCRYPTED in production)
  firstName         String    @db.Text
  lastName          String    @db.Text
  dateOfBirth       DateTime
  gender            String?

  // Contact (ENCRYPTED)
  email             String?   @db.Text
  phone             String?   @db.Text
  address           String?   @db.Text
  city              String?
  state             String?
  postalCode        String?
  country           String    @default("MX")

  // Medical Record Number
  mrn               String    @unique  // Internal MRN
  externalMrn       String?              // External system MRN

  // De-identification
  tokenId           String    @unique  // Public-facing token (e.g., PT-892a-4f3e-b1c2)
  ageBand           String?              // e.g., "30-39" for de-identified reports
  region            String?              // e.g., "SP" (São Paulo)

  // Metadata
  isActive          Boolean   @default(true)
  assignedClinicianId String?
  assignedClinician User?     @relation(fields: [assignedClinicianId], references: [id])

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  patientUser       PatientUser?
  medications       Medication[]
  appointments      Appointment[]
  consents          Consent[]
  documents         Document[]
  clinicalNotes     ClinicalNote[]
  prescriptions     Prescription[]
  scribeSessions    ScribeSession[]
  soapNotes         SOAPNote[]
  messages          Message[]
  healthMetrics     HealthMetric[]
  documentShares    DocumentShare[]
  formInstances     FormInstance[]

  @@index([mrn])
  @@index([tokenId])
  @@index([blockchainId])
  @@index([assignedClinicianId])
  @@map("patients")
}

// ============================================================================
// MEDICATIONS
// ============================================================================

model Medication {
  id                String    @id @default(cuid())
  patientId         String
  patient           Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Blockchain fields
  prescriptionHash  String?   // Hash for blockchain verification

  // Medication details
  name              String
  genericName       String?
  dose              String    // e.g., "500mg"
  frequency         String    // e.g., "2x/día", "BID"
  route             String?   // e.g., "oral", "IV"
  instructions      String?   @db.Text

  // Dates
  startDate         DateTime  @default(now())
  endDate           DateTime?

  // Status
  isActive          Boolean   @default(true)

  // Prescriber
  prescribedBy      String?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([patientId])
  @@index([isActive])
  @@map("medications")
}

// ============================================================================
// PRESCRIPTIONS (E-Prescribing)
// ============================================================================

model Prescription {
  id                String    @id @default(cuid())
  patientId         String
  patient           Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  clinicianId       String
  clinician         User      @relation(fields: [clinicianId], references: [id])

  // Blockchain fields - CRITICAL for tamper-proof prescriptions
  prescriptionHash  String    @unique  // SHA-256 hash of prescription data
  txHash            String?              // Blockchain transaction hash (future)
  blockTimestamp    DateTime?

  // Prescription content
  medications       Json      // Array of { drug, dose, frequency, duration }
  instructions      String?   @db.Text
  diagnosis         String?   @db.Text

  // Electronic signature
  signatureMethod   String    // "pin" or "signature_pad"
  signatureData     String    @db.Text  // Encrypted signature or PIN hash
  signedAt          DateTime  @default(now())

  // Status
  status            PrescriptionStatus @default(PENDING)
  sentToPharmacy    Boolean   @default(false)
  pharmacyId        String?

  // Audit
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([patientId])
  @@index([clinicianId])
  @@index([prescriptionHash])
  @@index([txHash])
  @@map("prescriptions")
}

enum PrescriptionStatus {
  PENDING
  SIGNED
  SENT
  FILLED
  CANCELLED
}

// ============================================================================
// CONSENTS (Blockchain-Ready)
// ============================================================================

model Consent {
  id                String    @id @default(cuid())
  patientId         String
  patient           Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Blockchain fields - CRITICAL for immutable proof
  consentHash       String    @unique  // SHA-256 of consent content + signature
  txHash            String?              // Blockchain transaction hash (future)
  blockTimestamp    DateTime?

  // Consent details
  type              ConsentType
  title             String
  content           String    @db.Text  // Full consent text
  version           String    @default("1.0")

  // Signature
  signatureData     String    @db.Text  // Base64 signature image or digital signature
  signedAt          DateTime
  witnessName       String?
  witnessSignature  String?   @db.Text

  // Status
  isActive          Boolean   @default(true)
  revokedAt         DateTime?
  revokedReason     String?   @db.Text

  // Audit
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([patientId])
  @@index([consentHash])
  @@index([txHash])
  @@map("consents")
}

enum ConsentType {
  GENERAL_CONSULTATION
  TELEHEALTH
  DATA_RESEARCH
  SURGERY
  PROCEDURE
  PHOTOGRAPHY
  CUSTOM
}

// ============================================================================
// APPOINTMENTS (Calendar Integration)
// ============================================================================

model Appointment {
  id                String    @id @default(cuid())
  patientId         String
  patient           Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  clinicianId       String
  clinician         User      @relation(fields: [clinicianId], references: [id])

  // Appointment details
  title             String
  description       String?   @db.Text

  // Date/Time
  startTime         DateTime
  endTime           DateTime
  timezone          String    @default("America/Mexico_City")

  // Calendar integration
  googleEventId     String?   @unique
  outlookEventId    String?   @unique
  calendarSyncedAt  DateTime?

  // Type
  type              AppointmentType @default(IN_PERSON)
  meetingUrl        String?          // For telehealth

  // Status
  status            AppointmentStatus @default(SCHEDULED)

  // Reminders
  reminderSent      Boolean   @default(false)
  reminderSentAt    DateTime?

  // Confirmation system
  confirmationStatus    ConfirmationStatus @default(PENDING)
  confirmationToken     String?            @unique
  confirmationSentAt    DateTime?
  confirmedAt           DateTime?
  confirmationMethod    String?            // 'sms', 'email', 'push', 'whatsapp'

  // Reschedule requests
  rescheduleRequested   Boolean            @default(false)
  rescheduleRequestedAt DateTime?
  rescheduleReason      String?            @db.Text
  rescheduleNewTime     DateTime?
  rescheduleApproved    Boolean?           // null = pending, true = approved, false = rejected
  rescheduleApprovedAt  DateTime?
  rescheduleApprovedBy  String?            // User ID who approved

  // Relations
  scribeSessions    ScribeSession[]

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([patientId])
  @@index([clinicianId])
  @@index([startTime])
  @@index([status])
  @@index([confirmationToken])
  @@index([confirmationStatus])
  @@map("appointments")
}

enum AppointmentType {
  IN_PERSON
  TELEHEALTH
  PHONE
  HOME_VISIT
}

enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  CHECKED_IN
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum ConfirmationStatus {
  PENDING           // Reminder not sent yet
  SENT              // Reminder sent, waiting for response
  CONFIRMED         // Patient confirmed
  RESCHEDULE_REQUESTED  // Patient requested reschedule
  CANCELLED_BY_PATIENT  // Patient cancelled
  NO_RESPONSE       // Patient didn't respond
}

// ============================================================================
// DOCUMENTS (De-identified, OCR processed)
// ============================================================================

model Document {
  id                String    @id @default(cuid())
  patientId         String
  patient           Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Blockchain fields
  documentHash      String    @unique  // SHA-256 of original document
  deidentifiedHash  String?              // Hash of de-identified version
  txHash            String?              // Future: blockchain storage proof

  // File details
  fileName          String
  fileType          String    // e.g., "pdf", "jpg", "docx"
  fileSize          Int       // bytes

  // Storage (Supabase Storage or S3)
  storageUrl        String    @db.Text  // Encrypted, de-identified version
  originalStorageUrl String?  @db.Text  // Original (highly restricted access)

  // Processing
  documentType      DocumentType
  ocrText           String?   @db.Text  // Extracted text (de-identified)
  entities          Json?                // Extracted medical entities

  // De-identification
  isDeidentified    Boolean   @default(false)
  phiDetected       Int       @default(0)
  deidentifiedAt    DateTime?

  // Metadata
  uploadedBy        String?
  processingStatus  ProcessingStatus @default(PENDING)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([patientId])
  @@index([documentHash])
  @@index([processingStatus])
  @@map("documents")
}

enum DocumentType {
  LAB_RESULTS
  IMAGING
  CONSULTATION_NOTES
  DISCHARGE_SUMMARY
  PRESCRIPTION
  INSURANCE
  CONSENT_FORM
  OTHER
}

enum ProcessingStatus {
  PENDING
  UPLOADING
  PROCESSING
  DEIDENTIFYING
  EXTRACTING
  SYNCHRONIZED
  FAILED
}

// ============================================================================
// CLINICAL NOTES (SOAP Notes, etc.)
// ============================================================================

model ClinicalNote {
  id                String    @id @default(cuid())
  patientId         String
  patient           Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Blockchain fields
  noteHash          String    @unique
  txHash            String?

  // Note content
  type              NoteType  @default(PROGRESS)
  subjective        String?   @db.Text  // S in SOAP
  objective         String?   @db.Text  // O in SOAP
  assessment        String?   @db.Text  // A in SOAP
  plan              String?   @db.Text  // P in SOAP

  // Additional
  chiefComplaint    String?   @db.Text
  diagnosis         String[]

  // Author
  authorId          String
  signedAt          DateTime?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([patientId])
  @@index([authorId])
  @@map("clinical_notes")
}

enum NoteType {
  PROGRESS
  CONSULTATION
  ADMISSION
  DISCHARGE
  PROCEDURE
  FOLLOW_UP
}

// ============================================================================
// TOKEN MAPS (For Re-identification - HIGHLY SECURED)
// ============================================================================

model TokenMap {
  id                String    @id @default(cuid())

  // Encrypted mapping
  encryptedMap      String    @db.Text  // AES-256 encrypted token->original mapping
  mapHash           String    @unique   // Hash for verification

  // Metadata
  recordType        String    // "patient", "document", etc.
  recordId          String

  // Access control
  createdBy         String
  accessCount       Int       @default(0)
  lastAccessedAt    DateTime?

  // Expiration (for temporary de-identification)
  expiresAt         DateTime?

  createdAt         DateTime  @default(now())

  @@index([recordId])
  @@index([mapHash])
  @@map("token_maps")
}

// ============================================================================
// AUDIT LOGS (Compliance - HIPAA requirement)
// ============================================================================

model AuditLog {
  id                String    @id @default(cuid())

  // Who
  userId            String?
  user              User?     @relation(fields: [userId], references: [id])
  userEmail         String?
  ipAddress         String
  userAgent         String?   @db.Text

  // What
  action            AuditAction
  resource          String    // e.g., "Patient", "Prescription"
  resourceId        String

  // Details
  details           Json?     // Additional context
  dataHash          String?   // Hash of data accessed/modified

  // Result
  success           Boolean   @default(true)
  errorMessage      String?   @db.Text

  // When
  timestamp         DateTime  @default(now())

  @@index([userId])
  @@index([action])
  @@index([resourceId])
  @@index([timestamp])
  @@map("audit_logs")
}

enum AuditAction {
  CREATE
  READ
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  EXPORT
  PRINT
  DEIDENTIFY
  REIDENTIFY
  PRESCRIBE
  SIGN
  REVOKE
  NOTIFY          // WhatsApp/Email/SMS notifications
  DOCUMENT_UPLOADED  // Document upload action
}

// ============================================================================
// BLOCKCHAIN TRANSACTIONS (Future)
// ============================================================================

model BlockchainTransaction {
  id                String    @id @default(cuid())

  // Transaction details
  txHash            String    @unique
  blockNumber       BigInt?
  network           String    @default("polygon-mainnet") // or "ethereum", "base"

  // What was recorded
  recordType        String    // "consent", "prescription", "document"
  recordId          String
  dataHash          String    // The hash that was recorded on-chain

  // Contract details
  contractAddress   String
  functionCalled    String
  gasUsed           BigInt?
  gasCost           String?   // in native token

  // Status
  status            TxStatus  @default(PENDING)
  confirmations     Int       @default(0)

  // Timestamps
  submittedAt       DateTime  @default(now())
  confirmedAt       DateTime?

  @@index([txHash])
  @@index([recordId])
  @@index([status])
  @@map("blockchain_transactions")
}

enum TxStatus {
  PENDING
  CONFIRMED
  FAILED
  REVERTED
}

// ============================================================================
// CALENDAR INTEGRATIONS (OAuth for Google, Microsoft, Apple)
// ============================================================================

model CalendarIntegration {
  id                String    @id @default(cuid())
  userId            String
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Provider
  provider          CalendarProvider
  providerAccountId String    // OAuth provider's user ID

  // OAuth tokens (ENCRYPTED in production)
  accessToken       String    @db.Text
  refreshToken      String?   @db.Text
  tokenExpiresAt    DateTime?
  scope             String[]

  // Calendar details
  calendarId        String?   // Primary calendar ID
  calendarName      String?
  calendarEmail     String?

  // Sync status
  lastSyncAt        DateTime?
  syncEnabled       Boolean   @default(true)
  syncErrors        Int       @default(0)

  // Metadata
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@unique([userId, provider])
  @@index([userId])
  @@index([provider])
  @@map("calendar_integrations")
}

enum CalendarProvider {
  GOOGLE
  MICROSOFT
  APPLE
}

// ============================================================================
// AI SCRIBE (World-Class Medical Transcription & SOAP Generation)
// ============================================================================

model ScribeSession {
  id                String    @id @default(cuid())
  patientId         String
  patient           Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  clinicianId       String
  clinician         User      @relation(fields: [clinicianId], references: [id])

  // Session metadata
  appointmentId     String?
  appointment       Appointment? @relation(fields: [appointmentId], references: [id])

  // Recording details
  audioFileUrl      String?   @db.Text
  audioFileName     String?
  audioDuration     Int       @default(0)  // seconds
  audioFormat       String    @default("webm")
  audioSize         Int?      // bytes
  startedAt         DateTime?
  endedAt           DateTime?

  // Processing
  status            ScribeStatus @default(RECORDING)
  processingStartedAt DateTime?
  processingCompletedAt DateTime?
  processingError   String?   @db.Text

  // AI Model
  transcriptionModel String?  @default("whisper-1")
  soapModel         String?   @default("claude-3-5-sonnet-20250219")

  // Relations
  transcription     Transcription?
  soapNote          SOAPNote?

  // Metadata
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([patientId])
  @@index([clinicianId])
  @@index([status])
  @@index([createdAt])
  @@map("scribe_sessions")
}

enum ScribeStatus {
  RECORDING
  PAUSED
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

model Transcription {
  id                String    @id @default(cuid())
  sessionId         String    @unique
  session           ScribeSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Raw transcript
  rawText           String    @db.Text

  // Speaker diarization
  segments          Json      // Array of { speaker, text, startTime, endTime, confidence }
  speakerCount      Int       @default(2)

  // Quality metrics
  confidence        Float     @default(0)  // 0-1
  wordCount         Int       @default(0)
  durationSeconds   Int

  // Processing metadata
  model             String    @default("whisper-1")
  language          String    @default("es")  // Spanish by default
  processingTime    Int?      // milliseconds

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([sessionId])
  @@map("transcriptions")
}

model SOAPNote {
  id                String    @id @default(cuid())
  sessionId         String    @unique
  session           ScribeSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  patientId         String
  patient           Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  clinicianId       String
  clinician         User      @relation(fields: [clinicianId], references: [id])

  // Blockchain fields - CRITICAL for tamper-proof notes
  noteHash          String    @unique
  txHash            String?

  // SOAP structure
  subjective        String    @db.Text
  subjectiveConfidence Float  @default(0)

  objective         String    @db.Text
  objectiveConfidence Float   @default(0)

  assessment        String    @db.Text
  assessmentConfidence Float  @default(0)

  plan              String    @db.Text
  planConfidence    Float     @default(0)

  // Additional clinical data
  chiefComplaint    String?   @db.Text
  vitalSigns        Json?     // { bp, hr, temp, rr, spo2, weight }
  diagnoses         Json      // Array of { icd10Code, description, isPrimary }
  procedures        Json?     // Array of { cptCode, description }
  medications       Json?     // Array of medication changes

  // Quality & editing
  overallConfidence Float     @default(0)  // 0-1
  wasEdited         Boolean   @default(false)
  editCount         Int       @default(0)
  editHistory       Json?     // Array of { field, oldValue, newValue, editedAt, editedBy }

  // Signature
  signedAt          DateTime?
  signedBy          String?
  signatureMethod   String?   // "pin" or "digital"

  // AI metadata
  model             String    @default("claude-3-5-sonnet-20250219")
  tokensUsed        Int?
  processingTime    Int?      // milliseconds

  // Status
  status            SOAPStatus @default(DRAFT)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([patientId])
  @@index([clinicianId])
  @@index([sessionId])
  @@index([status])
  @@index([createdAt])
  @@map("soap_notes")
}

enum SOAPStatus {
  DRAFT
  PENDING_REVIEW
  SIGNED
  AMENDED
  ADDENDUM
}

// ============================================================================
// PUSH NOTIFICATIONS (Web Push API)
// ============================================================================

model PushSubscription {
  id                String    @id @default(cuid())

  // Owner (polymorphic - clinician or patient)
  userId            String
  userType          UserType

  // Push subscription details (from browser)
  endpoint          String    @db.Text  @unique
  keys              Json      // { p256dh, auth } from PushSubscription

  // Device/Browser info
  userAgent         String?   @db.Text
  platform          String?   // e.g., "web", "android", "ios"
  deviceName        String?   // e.g., "Chrome on MacOS"

  // Status
  isActive          Boolean   @default(true)
  failedDeliveries  Int       @default(0)  // Track failed attempts
  lastUsedAt        DateTime  @default(now())

  // Preferences
  enabledTypes      String[]  // Array of NotificationType to receive

  // Metadata
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([userId, userType])
  @@index([endpoint])
  @@index([isActive])
  @@map("push_subscriptions")
}

// ============================================================================
// FORMS SYSTEM - Patient Forms & Consents
// ============================================================================

model FormTemplate {
  id                String        @id @default(cuid())

  // Template info
  title             String
  description       String?       @db.Text
  category          FormCategory
  isBuiltIn         Boolean       @default(false)  // Pre-built vs custom
  isActive          Boolean       @default(true)

  // Template content (JSON structure or file reference)
  structure         Json?         // For drag-and-drop forms { fields: [...], logic: {...} }
  fileUrl           String?       // For uploaded PDF/DOCX templates
  fileType          String?       // "pdf", "docx", "json"

  // Creator (if custom template)
  createdBy         String?
  clinician         User?         @relation(fields: [createdBy], references: [id], onDelete: SetNull)

  // Usage tracking
  usageCount        Int           @default(0)

  // Metadata
  version           Int           @default(1)
  tags              String[]      // ["consent", "hipaa", "intake", etc]
  estimatedMinutes  Int?          // How long to fill out

  // Timestamps
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relations
  formInstances     FormInstance[]

  @@index([category])
  @@index([isBuiltIn])
  @@index([isActive])
  @@index([createdBy])
  @@map("form_templates")
}

enum FormCategory {
  CONSENT                 // General consent forms
  HIPAA_AUTHORIZATION    // HIPAA release forms
  MEDICAL_HISTORY        // Health history intake
  TREATMENT_CONSENT      // Specific treatment consent
  FINANCIAL_AGREEMENT    // Payment/billing forms
  INSURANCE_INFORMATION  // Insurance details
  REFERRAL              // Referral forms
  CUSTOM                // Custom uploaded forms
}

model FormInstance {
  id                String            @id @default(cuid())

  // Template reference
  templateId        String
  template          FormTemplate      @relation(fields: [templateId], references: [id], onDelete: Restrict)

  // Assignment
  patientId         String
  patient           Patient           @relation(fields: [patientId], references: [id], onDelete: Cascade)

  assignedBy        String
  assignedByUser    User              @relation(fields: [assignedBy], references: [id], onDelete: Restrict)

  // Status tracking
  status            FormStatus        @default(PENDING)
  sentAt            DateTime          @default(now())
  viewedAt          DateTime?
  startedAt         DateTime?         // When patient started filling
  completedAt       DateTime?
  signedAt          DateTime?

  // Submission data
  responses         Json?             // Structured form responses
  submittedData     Json?             // Full submission payload

  // E-signature
  signatureDataUrl  String?           @db.Text  // Base64 signature image
  signatureIp       String?
  signedUserAgent   String?           @db.Text

  // File attachments (if patient uploads documents)
  attachments       String[]          // Array of Document IDs

  // Access control
  accessToken       String            @unique  // Unique link token for patient access
  accessTokenHash   String            @unique  // SHA-256 hash for lookup
  expiresAt         DateTime?

  // Reminders
  remindersSent     Int               @default(0)
  lastReminderAt    DateTime?

  // Progress tracking
  progressPercent   Int               @default(0)
  currentStepIndex  Int               @default(0)

  // Audit trail
  dataHash          String?           // SHA-256 of final submission
  ipAddress         String?

  // Metadata
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // Relations
  auditTrail        FormAuditLog[]

  @@index([patientId])
  @@index([assignedBy])
  @@index([status])
  @@index([accessToken])
  @@index([accessTokenHash])
  @@index([completedAt])
  @@map("form_instances")
}

enum FormStatus {
  PENDING         // Sent, not opened
  VIEWED          // Patient opened the form
  IN_PROGRESS     // Patient started filling
  COMPLETED       // Submitted but not signed
  SIGNED          // Fully completed with signature
  EXPIRED         // Link expired
  REVOKED         // Clinician revoked access
}

model FormAuditLog {
  id                String        @id @default(cuid())

  formInstanceId    String
  formInstance      FormInstance  @relation(fields: [formInstanceId], references: [id], onDelete: Cascade)

  // Event details
  event             FormAuditEvent
  description       String?       @db.Text

  // Actor (patient or clinician)
  userId            String?       // PatientUser or User ID
  userType          String?       // "patient" or "clinician"

  // Context
  ipAddress         String?
  userAgent         String?       @db.Text
  metadata          Json?

  // Timestamp
  createdAt         DateTime      @default(now())

  @@index([formInstanceId])
  @@index([event])
  @@index([createdAt])
  @@map("form_audit_logs")
}

enum FormAuditEvent {
  SENT              // Form sent to patient
  VIEWED            // Patient opened form
  STARTED           // Patient started filling
  PROGRESS_SAVED    // Auto-save progress
  SUBMITTED         // Patient submitted form
  SIGNED            // E-signature added
  REMINDER_SENT     // Reminder email/SMS sent
  EXPIRED           // Form link expired
  REVOKED           // Clinician revoked form
  UPDATED           // Clinician updated form
  DOWNLOADED        // PDF downloaded
}
